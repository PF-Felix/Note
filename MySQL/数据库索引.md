# B+树索引

## 聚簇索引

> 也叫聚集索引、主键索引

InnoDB引擎 用表的主键构造了一个B+树，整个表的行记录数据（数据页）存放在叶子节点中，这就是聚簇索引**数据绑定于索引**
MyISAM引擎 索引文件和数据是分离的，叶子节点存储的是数据记录的地址，是非聚簇索引（主键索引和二级索引都是）

**每个表只有一个聚簇索引**
如果没有定义主键呢，数据库使用唯一索引
如果还没有唯一索引，就使用一个隐含列 RowID 来做主键

**主键和唯一索引的区别？**
主键不能为空，唯一键可以
主键是给二级索引引用的
主键只有一个，唯一索引不限个数

## 辅助索引

> 也叫二级索引

在非主键列建立的索引是辅助索引，叶子节点存储的是主键的值
每个表可以有多个辅助索引
PS：MyISAM 辅助索引叶子节点存储的是数据记录的地址
### 联合索引

> 也叫复合索引

在多个字段上建立的一个索引称之为联合索引
联合索引是辅助索引

## 回表

通过辅助索引寻找数据，先通过辅助索引寻找到其叶子节点存储的主键，再通过聚簇索引来找到一个完整的行记录，这个过程也被称为回表

~~为什么不直接把完整的用户记录放到辅助索引叶子节点呢？~~
1、浪费存储空间
2、数据变化更新所有索引性能低下

## 索引覆盖

意思是从辅助索引中就可以得到查询的记录，不需要回表
![zoom=40](Pasted%20image%2020231216154731.png)

# 哈希索引

B+树的查找次数取决于树的高度，需要多次IO查询

数据库监控经常用的索引，为其创建了一个哈希索引（速度优于B+树）称为自适应哈希索引
查询的时候如果能命中自适应哈希索引就不用再使用B+树索引

哈希索引只能用来搜索等值的查询

是否开启此特性`innodb_adaptive_hash_index`默认为开启状态

# 密集索引_稀疏索引

**密集索引**叶子节点保存的不只是键值，还保存了位于同一行记录里的其他列的信息，一个表只能创建一个密集索引
**稀疏索引**叶子节点仅保存了键位信息以及该行数据的地址

MyISAM 的所有索引都是稀疏索引
InnoDB 有且只有一个密集索引即聚集索引，二级索引是稀疏索引

# 高性能索引_创建

## 索引列类型尽量小

> 类型表示的数据范围的大小

数据类型越小，在查询时比较操作越快
数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘IO带来的性能损耗

## 选择离散性高的列

重复的数据少，能过滤掉更多的数据

## 前缀索引

针对很长的 varchar、blob、text 需建立前缀索引
缺点：无法做 ORDER BY 和 GROUP BY
后缀索引：Mysql 不支持，但是可以把字符串反转后存储，并基于此建立前缀索引

## 为条件、排序、分组列创建索引

出现在查询列表中的列一般就没必要建立索引了，除非是需要使用索引覆盖

## 联合索引的列顺序至关重要

将离散性最高的列放到索引最前列
在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求

## 三星索引

1、索引将相关的记录放到一起则获得一星（比重27%）（索引行相邻或足够靠近最好）
2、如果索引中的数据顺序和查找中的排列顺序一致则获得二星（排序星：比重27%）（不用再另外排序）
3、如果索引中的列包含了查询中需要的全部列则获得三星（宽索引星：比重50%）（索引覆盖避免回表）

# 高性能索引_优化

## 不在索引列上做任何操作

做计算：`SELECT * FROM order_exp WHERE id + 1 = 17;`
用函数：`SELECT * from order_exp WHERE YEAR(insert_time)=YEAR(DATE_SUB(NOW(),INTERVAL 1 YEAR));`
上面的情况都无法利用索引，索引失效

## 字符串加引号_整型不要加引号

两种情况的反例都会触发隐式类型转换，会导致索引失效

## is null & is not null

大概率导致索引失效（不是一定但可能性很大）

## %开头的like

索引失效

## or需要注意

如果所有查询条件的列都有索引，那么可以使用索引合并来优化查询
如果只有部分列有索引，或者没有索引，那么不会使用索引

## 联合索引全值匹配_最左匹配原则

不是全值匹配的话也应该遵循最左匹配原则，必须匹配最左边的列

## 使用索引覆盖避免回表

无需回表

## 联合索引用后面列范围查询

使用前面索引列范围查询，后面索引列失效

## 不等于

使用不等于将无法使用索引导致全表扫描

## 按主键顺序插入记录

最简单的是自增主键，插入数据时，写入的目标页很可能是缓存中已有的页，顺序写入更快

UUID 这种插入记录时是乱序的
1、写入的目标页可能不在缓存中或者已经被淘汰，此时就需要大量随机IO
2、写入是乱序的，需要大量的移动数据

## 联合索引排序

对于使用联合索引排序，必须满足下面规则，否则索引排序失效
1、各个索引列排序规则必须一致，都是ASC or 都是DESC
2、索引列顺序和 order by 子句顺序完全一致

## 其他索引失效场景

优化器认为使用全表扫描要比使用索引快，则不使用索引

join 的两个表的字符编码不同，不能命中索引
# 准确性和实时性要求不高的情况

查数据，如果缓存中没有就查库+写缓存（有过期时间），如果缓存有数据就用缓存数据
写数据，直接写数据库

适合对数据准确性实时性要求不高的场景，比如商品关注的人数、视频的点赞数

# 准确性和实时性要求较高的情况

这种情况下就需要保证双写一致性了

我们讨论四种情况

## 先更新缓存，再更新库

这个方案我们一般不考虑

原因是更新缓存成功之后，更新数据库出现异常了，导致缓存数据与数据库数据不一致
数据库更新异常回滚缓存？做不到吧，即使能做到实现也是比较麻烦的
数据库更新异常删除缓存？这等价于下面将要提到的方法

## 先更新库，再更新缓存

这个方案我们一般也不考虑

原因是数据库更新成功了，缓存更新失败，同样会出现数据不一致问题
缓存更新失败回滚数据库？有些业务是会受影响的，我们应该保证的是落库成功就是成功，缓存最终会和数据库保持一致
缓存更新失败删除缓存？等价于下面将要提到的方法

除此之外这个方案在并发场景下存在数据不一致的问题，举例如下

1. 线程A更新了数据库
2. 线程B更新了数据库
3. 线程A更新了缓存
4. 线程B更新了缓存

实际情况是 1先于2，但是由于网络原因 4先于3，此时就是数据不一致

## 先删缓存，再更新库

此方案在并发场景下也有数据不一致的问题，举例如下：

1. 几乎同时一前一后来了两个请求，A是更新 B是查询
2. A 先删除缓存，然后去更新数据库；此时B 看到缓存是空的就去查数据库
3. 正常的情况是A更新成功，然后B读到新数据并写入缓存
   但是读大概率比写快，很有可能的情况是B读到旧值写入缓存，然后A更新成功

如何解决呢？**延时双删策略**，如下

1. 先删除缓存
2. 再更新数据库
3. 睡眠1秒，再次删除缓存

延迟双删可以将1秒内的脏数据再次删除
这个1秒需要根据业务计算，一般是在读操作的耗时基础上加上几百毫秒
计算得到的睡眠时间也不是100%就能保证数据一致，因此可以根据业务需求适当睡眠时间长一些提高这个概率

还存在一个问题？如果数据库是读写分离架构，数据同步也有一定时间差
解决方案1：还是用延迟双删，睡眠时间为主从同步的延时时间基础上加上几百毫秒
解决方案2：让查询走主库

**延时双删同步异步的问题**

如果延时双删失败了怎么办？重试
假如延时双删是同步的，多次重试将严重影响系统的吞吐量；而且延时双删本身需要先睡眠一定的时间，也会影响吞吐量
因此延时双删应该做成异步的，另外启动一个线程，异步删除
延时双删优雅的做法是使用 canal 订阅 binlog + 删除，如果删除失败就发送到 MQ 由消费者再次尝试删除缓存
这个方法的优点是延时双删和业务代码解耦

**延时双删还存在的问题**

1、第一次删除缓存如果失败了不好处理
2、而且两次删除没有必要，保留最后一次就可以了

因此综合来看下面第四种的方案更好一些

## ⭐先更新库，再删缓存

> 这也是经常采用的方式

使用上面的延时删除策略，去掉第一步的删除缓存即可：

1. 更新数据库
2. 睡眠一定时间之后删除缓存

此方案在并发场景下也有数据不一致问题（前提：缓存无数据，数据库有数据），举例如下：

1. A查询，B更新
2. A查缓存无数据，去读数据库读到旧值
3. B将数据库更新为新值并删除缓存
4. A将旧值写入缓存

只有在满足前提，且读比写慢的情况下才会出现，概率极低

**存在的问题**

1. 删除缓存失败怎么处理
2. 上述概率极低的情况处理

延时双删可以同时解决这两个问题

1. 更新数据库
2. 删除缓存（不用关心成功还是失败）
3. 延时双删

# 允许数据丢失的情况

把缓存当作数据库来用，业务线程只写缓存不写数据库，异步将缓存同步到数据库

速度极快
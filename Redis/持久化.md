[内存数据持久化的两种方式](内存数据持久化的两种方式.md)

# RDB

时点数据、快照、全量备份

**是否阻塞主线程？**

- save：在主线程中执行，将导致阻塞
- bgsave：创建一个子线程，用来备份数据（将内存复制一份用于子进程的备份）
- 除了上面两种手动触发备份的方式，还可以通过配置自动触发备份，如下图

![zoom=70](Pasted%20image%2020231216051128.png)

执行 shutdown 命令时如果没有开启 AOF 将触发 bgsave

时点性：假如1点开始备份数据，1点以后的数据不会被备份

子进程将数据写入临时 RDB 文件中，完成写入时用临时 RDB 替换掉旧的 RDB

优点：1、数据恢复速度快；2、全量数据，可用于灾难恢复
缺点：做不到实时持久化

# AOF

> append only file

记录每次写操作的日志，默认不开启

先写缓冲区，择时同步磁盘

- always：每个写命令执行完，立马同步地将日志写回磁盘（对性能影响太大，不建议配置）
- everysec：每个写命令执行完，先把日志写入内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘（默认配置，理论上只有在系统突然宕机的情况下丢失1秒的数据）
- no：每个写命令执行完，先把日志写入内存缓冲区，由操作系统决定何时写磁盘，通常是30秒（写磁盘周期不可控，虽然提升了性能，但数据安全性无法保证）

命令不断写入 AOF 越来越大，为了解决这个问题，重写机制压缩 AOF 的体积，同时还能加快数据恢复速度

优点：丢失数据少
缺点：数据恢复速度没有RDB快

同 RDB 一样都是子进程异步备份

**重写机制**

随着命令不断写入 AOF，文件会越来越大，为了解决这个问题，Redis 引入 AOF 重写机制压缩文件体积

文件重写是把 Redis 进程内的数据转化为写命令同步到新 AOF 文件

文件变小的原因：
1、最终数据去掉了无效命令，因此文件变小
2、多条写命令可以合并为一个

**重写过程触发**

手动触发：直接调用 bgrewriteaof 命令

自动触发：根据`auto-aof-rewrite-min-size`和`auto-aof-rewrite-percentage`参数确定触发时机
`auto-aof-rewrite-min-size`表示运行 AOF 重写时文件的最小体积，默认为64MB
`auto-aof-rewrite-percentage`代表当前 AOF 文件空间和上一次重写后 AOF 文件空间的比值

AOF 重写时，如果有写入操作，这个操作会被写到重写日志的缓冲区保证数据不会丢失

**重启加载**

1、当AOF和RDB文件同时存在时，优先加载AOF；若关闭了AOF，加载RDB文件
2、加载 AOF/RDB 成功，Redis重启成功
3、AOF/RDB 存在错误，启动失败打印错误信息

# RDB-AOF混合持久化

通过`aof-use-rdb-preamble`配置项可以打开混合开关，默认是禁用的

该状态开启后，如果执行 bgrewriteaof 命令，会把当前内存中已有的数据弄成二进制存放在 AOF 文件中（即RDB）
后面有其他命令，在触发下次重写之前，依然采用 AOF 追加的方式

# 为什么主从复制不用AOF

1、RDB 是二进制文件，无论是写入磁盘，还是通过网络传输，IO效率 AOF 的高
2、在从库进行恢复时，RDB 的恢复效率更高
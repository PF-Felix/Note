# 数据阈值式清理

**maxmemory**Redis 提供了配置参数 maxmemory 来限制内存超出期望大小，当实际内存超出 maxmemory 时，可选的淘汰策略如下：

**Noeviction**默认的淘汰策略，不会继续服务写请求（DEL可以），读请求可以继续进行

**volatile-lru**只淘汰设置了过期时间的key；淘汰算法是LRU，最少使用的 key 优先被淘汰
**volatile-lfu**同上；淘汰算法是LFU
**volatile-ttl**跟上面一样；淘汰策略TTL：ttl 越小越优先被淘汰
**volatile-random**跟上面一样，随机淘汰

**allkeys-lru**区别于 volatile-lru，这个策略要淘汰的是全体的 key，没有设置过期时间的 key 也会被淘汰；淘汰算法是LRU
**allkeys-lfu**同上；淘汰算法是LFU
**allkeys-random**同上，随机淘汰

推荐使用 LRU 或 LFU 算法，避免热点 key 被淘汰，可以提高缓存命中率

## LRU算法

实现 LRU 算法除了需要 KV 字典外，还需要附加一个链表
当空间满的时候，会踢掉链表尾部的元素
当字典的某个元素被访问时，它在链表中的位置会被移动到表头

## 近似LRU算法

Redis 使用一种近似 LRU 算法，之所以不使用 LRU，是因为需要消耗大量额外内存，需要对现有数据结构进行较大改造

- 近似 LRU 算法给每个 key 增加了一个24位的时钟字段，存储最后一次被访问的时间戳
  Redis 维护了一个24位的全局时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟
- 当新增 key 对象的时候会把全局时钟赋值到这个 key 对象的时间戳字段
- 执行淘汰策略的时候，随机采样出 5个key（可配置），然后找到内部时间戳与全局时钟距离时间最久（差最大）的 key 进行淘汰，之后如果内存还是超出 maxmemory，继续随机采样淘汰

## LFU算法

它的核心思想是根据 key 的最近被访问的频率进行淘汰，很少被访问的优先被淘汰

LFU 算法能更好的保留热点数据

原理：使用计数器来对 key 进行排序，每次 key 被访问的时候计数器增大，计数器相等的 key 按照时间排序

LFU 把 key 对象的内部时钟的24位作为“热度”分成两部分

- 前16位还代表时钟，存储上一次计数器更新的时间，16位精度不可能很高，它取的是分钟时间戳对2的16次方进行取模
  平时不更新，进行缓存淘汰时才更新
- 后8位是一个计数器存储访问频次（8位最大表示整数255，不够用，所以它存储的是频次的对数，并且这个值还随着时间衰减）

每次淘汰都是采用随机策略，随机挑选若干 key，更新这个 key 的“热度”，淘汰掉“热度”最低的 key

# 过期式清理

**定时扫描策略**

Redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，定时扫描这个字典来删除到期的 key
默认每秒进行十次过期扫描，过期扫描不会遍历字典中所有的 key，而是随机策略
1、从字典中随机 20 个 key，删除这 20 个 key 中已经过期的 key
2、如果过期的 key 比率超过 1/4，就重复步骤 1

此时存在一个问题，如果大量的 key 同一时间过期了，这个循环会执行多次，这就会导致读写请求明显卡顿
所以开发者要注意过期时间，如果有大批量的 key 过期，要给过期时间设置一个随机范围，而不能全部在同一时间过期

从库的过期策略？没有策略；主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库

**惰性删除**

除了定时扫描之外，Redis 还会使用惰性策略来删除过期的 key，即客户端访问这个 key 的时候，如果过期了就立即删除

**lazyfree**

使用 DEL 命令删除体积较大的键，或者在使用 FLUSHDB 和 FLUSHALL 删除包含大量键的数据库时，会造成 Redis 阻塞

另外 Redis 在清理过期数据和淘汰内存超限的数据时，如果碰巧撞到了大体积的键也会造成服务器阻塞

为了解决以上问题，~~Redis4.0~~引入了 lazyfree 的机制，删除对象时只是异步逻辑删除，后台线程执行真正的删除
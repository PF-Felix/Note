**功能上就是两个**

- 发红包：支付 → 创建红包
- 抢红包：红包是否还有余量？
  - 抢光了：不让点了
  - 还有：开红包，更新红包记录

![zoom=80](61f9e3db8d8c1653db3ab615107fd57c.png)

**数据库表的设计**

两个表，发红包的流程（插红包表）、抢红包的流程（插红包流水表，更新红包表）

**初步思考与设计**

抢红包并发量越大，设计就越复杂，我根据用户量多少给了几个方案

假设一个用户抢红包，需要操作数据库耗时20ms，用户能够接受3s的等待抢到红包

关键是卡在更新红包表这里，并发场景下为避免超卖，检查库存+扣减库存必须得加锁排队

~~如果发放的红包个数是100~~，即允许100个人并发更新，耗时就是2s，能够满足需求

~~如果红包个数是1000~~就难受了

优化方案：

将一个红包拆成10个子红包，开红包时开一个剩余份数最多的红包，或者通过运算将红包id和用户id绑定

降低了锁的粒度，提高了并发量，也就是分流，直流越多，并发量越大

~~1000W的并发量怎么办呢？数据库会挂的~~

使用数据库扣库存慢，用缓存解决

数据一致性问题？
如果要求强一致就又回到了原点因此不可行，可以先将数据持久化到 MQ（比操作数据库快得多）消费者消费消息保证最终一致性

~~由此可见抢红包和秒杀是非常相似的~~

**以微信红包为例**

一个红包就相当于一个商品的秒杀

以微信的用户量，相当于海量的商品同时参与秒杀，因此并发量比电商平台的商品秒杀要大的多

而且微信红包本质上是资金交易，安全级别更高，绝对不允许超卖，少卖（即有红包未被领取）则必须保证精确回款

因此如果架构设计能够满足微信红包的业务场景，那么电商平台的商品秒杀也没问题

【秒杀】中的架构方案已经可以了，将同一个红包的并发路由到一个特定的服务上即可

**以支付宝红包雨为例**

与微信红包不一样的地方是，红包雨就只有一个红包，所有用户参与抢红包

因此这个场景下，对于单个红包的并发量方面，要比微信红包大的多得多

如果用上面微信红包的解决方案

- 假设同时抢红包的人是1000W，单个服务是支撑不住的
- 而且单个服务可用性不高

继续优化：把红包雨的一个红包拆成100份（上文中的思路），特定路由分流给100个服务处理

缺点：客户端不知道哪个红包还有余量，会出现用户没抢到红包但实际上红包还有剩余的情况

**用户收到提示红包抢到了，但实际没有到账，可能是下面的两个原因**

1、Redis 锁库存成功，但是给MQ发消息失败了即数据没有持久化
2、MQ消息过多消费比较慢
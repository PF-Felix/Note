# 场景&瓶颈&关注点

**秒杀将会产生大量的刷新商品详情页的操作，对商品中心会造成一定的负担**

针对这种场景可以关注的点有：

- 动静分离，静态资源就不要请求后端服务集群了，越往前放越好，比如放在网关
- 客户端优化，参考 [三高架构](https://www.yuque.com/felix.y/dns6b6/fdcge7xpisil11zd)
- 使用CDN，参考《三高架构》
- 使用缓存，把商品详情所需内容缓存起来，避免请求数据库

**为了避免超卖的问题，一般的下订单扣库存都是加分布式锁排队更新数据库的，这就不适合秒杀了，因为秒杀的并发量很大会卡住影响用户体验**

针对这种场景可以关注的点有：

- 使用缓存暂时代替数据库，加快业务处理速度
- 异步处理，快速响应

**如果有恶意流量频繁下单不支付，或者支付了后续都申请退款，很可能影响商品的销售，因为扣除的库存短时间内无法恢复，如果商品卖光了，其他用户想买却买不到**

针对这种场景可以关注的点有：

- 人机交互，让其付出代价，比如下单前需要输入验证码
- 设置只能卖一件，一般的用户也不会买多件
- 将超时未支付自动取消的时间缩短，尽快恢复库存
- 取消订单三次就不允许再购买了

**其他**

- 隔离：将秒杀业务作为独立的服务部署，避免影响到主业务，下面会讲到隔离的使用场景

# 业务流程

## 活动上线

1. 新建秒杀活动
2. 添加参与秒杀活动的商品，参与了秒杀的商品，不能再参与其他的秒杀场次
   添加商品锁库存，库存不够无法添加
3. 定时任务扫描未开始的最近的三个秒杀活动，如果未上线就将活动上线
   1. 更新秒杀活动的状态为上线，上线成功就继续操作
   2. 给 RocketMQ 发消息，发送失败就回滚
4. 消费者监听到消息就做下面的操作，下面操作都是异步
   1. 将未上架的秒杀商品上架，保证能被搜索引擎搜索到
   2. 查询秒杀活动信息存入 Redis
      KV 是 【秒杀活动+秒杀活动ID】/【活动信息】
      这里以及下面的过期时间都是活动结束后5分钟
   3. 查询活动关联的所有 SKU 详细信息封装到 Redis 中
      KV 是【秒杀商品列表+秒杀活动ID+SKUID】/【SKU详细信息+活动开始和结束时间】
   4. 查询 SKU 库存作为信号量加入缓存（Redisson）
      key是【秒杀商品库存+秒杀活动ID+SKU_ID】
   5. 如果所有操作都成功返回成功
      只要有一个操作失败就返回失败，稍后继续消费这个消息
5. 定时任务扫描上线的所有秒杀活动，下线所有过期的活动，下架所有秒杀商品

**为什么不把步骤3+4做成一个过程而是要拆开呢？**为了保证最终一致性

## 客户端展示

查的都是缓存

1. 以【秒杀活动】作为 key 前缀，查到所有的上线的秒杀活动
2. 以【秒杀商品列表+秒杀活动ID】作为 key 前缀，查到商品列表包括详细信息
3. 商品详情中库存查【秒杀商品库存+秒杀活动ID+SKU_ID】

## 秒杀流程

**为了不和其他业务耦合，秒杀商品不支持添加购物车**

1. 点击购买，提交商品信息+收货地址
2. 合法性校验
   1. 活动是否上线 即缓存有没有
   2. 活动是否过期 比较当前时间和商品的过期时间
   3. 购买数量是否超出限购数量
   4. 用Token校验幂等性
3. 获得信号量+扣库存
4. 生成分布式订单号 + 封装订单信息 + 【异步】发送给 RocketMQ + 立即响应
   每秒查一次订单，查到订单之后跳转到支付
5. 【订单服务】监听到消息，快速生成订单（此时用户还未支付）
   异步发送延时消息用来订单超时未支付自动取消，发送失败就重新消费消息
   另一种方案是定时任务扫描，缺点是可能存在较长的延时
   这里只插入订单，不能扣减数据库库存，因为超时未支付恢复库存比较麻烦
6. 支付：支付与修改订单状态应该是一个事务，可以使用分布式事务
   1、更新订单状态为支付中
   2、支付预下单（异常回滚）
   3、支付成功更新订单状态为已支付、失败回滚、无响应就回查
   这里也不能扣减数据库库存，理由同上，会阻塞
   定时任务扫描支付成功的订单扣减数据库库存

# 高可用问题

如果用 Redis 来做限流+快速响应，RocketMQ 异步生成订单
1、单节点的 Redis 会挂
2、使用哨兵主从：Redis 可能出现主从不一致，导致超卖

**那怎么做到高可用呢？**

3、给每个秒杀服务安装一个 Redis，参与秒杀的商品根据ID路由到特定的服务节点处理，即每个服务负担一部分商品的秒杀，即使某个服务或者同机的 Redis 挂掉，也只会影响到一部分商品；缺点是无法做到实时的横向扩展，而且这样做的话秒杀业务的部署就比较复杂了，有必要独立出来，不要影响其他服务

# RocketMQ相关的问题

## 秒杀step5为什么异步发消息

同步可能长时间阻塞，而秒杀应该做到快速响应，因此异步更合适

**消息发送失败怎么办?**

即便设置了多次重试依然可能失败

![zoom=75](1684476581082-0b49bb0b-cd36-4750-a5f2-f1a1d475e964.png)

最终还是发送失败？相当于下单失败了，需要恢复库存

## 同步双写VS异步双写

选同步双写，保证不会因为主节点宕机影响数据一致性

## 消息重复发送的问题

消费者需要做幂等处理

![zoom=70](1684477331236-0007bb36-dcff-4b20-93f6-91fc55698f9c.png)

# 超卖和少买的问题

**超卖**

即不能出现最后库存是负数的情况

一般的避免超卖的办法

1. 悲观锁：加互斥锁，有库存才允许扣减
2. 乐观锁+重试

在这里利用 Redisson 信号量（LUA脚本实现）做 库存判断+扣库存 本身就是带锁的，因为执行LUA脚本时不会执行其他脚本和 Redis 命令，因此超卖问题不存在

**少卖**

取消订单要恢复 Redis 库存
# 分布式ID应具备的特点

- 全局唯一
- 高性能
- 高可用
- 简单易用
- 递增：局部递增即可

# UUID

**优点**
- 全局唯一
- 简单易用，JDK自带可以不用依赖于任何第三方服务

**缺点**
- 完全无序，插入数据造成频繁的页分裂，数据量大时严重影响性能

# 数据库

利用数据库的自增主键

## 单机问题

**可用性差** ~~性能低~~

如果使用 mysql 单实例：性能可能不够；单实例的稳定性不强，宕机会影响业务

## 集群解决高可用

**方案一：使用主从模式集群，做到高可用**

存在的问题：数据同步延时问题，宕机可能导致ID重复

**方案二：使用多主集群（相互无关联），如果一个主宕机获取ID失败，就去请求另一个主，同时报警提醒**

举例：比如两个主机 master1 只产生奇数ID，master2 只产生偶数ID

- 必须设置自增起始值与步长
- 不能要slave，因为故障切换可能引起ID重复问题

![](065daa935d9f7720ce955d8876176ac5.png)

存在的问题：
1、性能可能依旧不足，每次都去请求数据库
2、如果再新增一个主，扩展起来麻烦

## 号段模式解决性能问题

**方案三：使用号段模式，批量从数据库获取ID缓存起来，缓存中的ID一旦达到上限时再去数据库批量获取**

DB设计如下：

> biz_type：代表业务类型，用作业务隔离
> max_id：代表当前最大的可用id
> step：代表号段的长度，合理设置即可
> version：是一个乐观锁，用来保证并发更新的正确性

![zoom=55](a299e625897ad711379ee223d72e3520.png)

## 高可用+高性能方案

结合方案二和方案三的优点，DB设计如下：

> delta：表示缓存中的 ID 每次增量
> remainder：代表余数

![zoom=50](37994b53849861942a5ccfb490a530a7.png)

仍然有缺点
1、扩展主机个数麻烦
2、实现复杂
3、依赖数据库

开源的实现方案有《美团Leaf》《滴滴TinyId》

# Redis

可以采取类似上文数据库的解决方案，而且因为 Redis 性能极高，因此不用方案三，使用方案二就能够解决问题了

仍然有相同的缺点
1、扩展主机个数麻烦
2、依赖Redis

# 雪花算法

使用一个64位的 long 类型作为 ID

- 第一位0表示正数 + 41位毫秒级时间戳 + 10位主机编号 + 12位序列号
- 时间戳通常是相对时间，这样可用期限就更长，理论上支持 69 年
- 支持 1024-1=1023 个主机节点
- 支持同一个时间点同一台服务器生成 4096-1=4095 个序列号
- 主机编号的位数和序列号的位数可以做适当调整

存在的问题：
1、时钟回拨可能造成ID重复，可以缓存最大时间解决这个问题，见《美团Leaf》
2、主机编号手动分配太麻烦了，可以在 Zookeeper 中创建序列节点，用节点序号作为主机编号

开源的实现方案有《美团Leaf》，而且使用 Zookeeper 生成序号取回之后缓存在本地，对 ZK 是弱依赖
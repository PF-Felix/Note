# 数据库

- 悲观锁的实现：使用排它锁，select for update
- 乐观锁的实现：可以通过 version 字段实现，也可以使用唯一索引实现

**缺点1**大量请求拿不到锁不停重试，造成对数据库的压力
**缺点2**数据库有宕机风险，主从也不行可能丢失数据

# Redisson

基于`Redis SETNX`实现分布式锁，遇到的问题以及解决方案：

1. 死锁？设置过期时间
2. 锁过期，其他线程获得了锁怎么办？守护线程，自动续期
3. 锁被别人释放？锁写入唯一标识，释放锁先检查标识，再释放
4. 可重入锁？还需记录重入次数，上面需记录唯一标识，因此简单的 KV 不行，可以用 hash hset

代码实现参考《语雀文档》，上面这些 redisson 都已经实现了

**问题：未抢到锁的线程如果轮询抢锁，可能造成很多无效的IO**
可以用基于发布订阅的回调方式抢锁，这点 redisson 也实现了

**问题：单节点Redis 做不到高可用**
可以使用哨兵主从，但是主从复制是异步的，可能出现主加锁后挂了，没有同步到从，其他线程可以获得锁

与数据库相比就是速度快，因此有了这种方案是绝对不会使用数据库的。

# RedLock

![zoom=60](Pasted%20image%2020231217090828.png)

![zoom=50](Pasted%20image%2020231217090848.png)

**举例说明时钟漂移**

1、客户端1获得了A、B、C节点上的锁，由于网络问题，无法到达D和E
2、节点C上的时钟向前跳动，导致锁过期
3、客户端2获得了节点C、D、E的锁，由于网络问题，A和B不能被联系到
4、客户端1和2现在都认为他们持有锁
也或者，在第二步骤，节点C如果出现宕机，恢复后没有之前的数据，客户端2也可能获取到锁

如果应用追求高性能就用 redisson（哨兵主从，只有很小几率发生锁丢失)
如果应用想要保证正确性，可以使用 zookeeper

# Zookeeper

**加锁和解锁过程**

1. 线程在目录下创建一个临时序列节点
2. 线程获取目录下的所有节点
    1. 如果它刚才创建的节点是最小节点，我们就认为这个线程获得了锁
    2. 如果不是最小节点，这个线程阻塞，同时监听比自己小的节点的删除事件
3. 线程结束删除这个节点，相当于释放锁，唤醒监听删除事件的线程获得锁（客户端断开连接也删除节点）

**能够解决 Redis 存在的所有痛点**

- 死锁：临时序列节点能确保不死锁
- 重复锁：客户端保持连接锁就存在，连接断开节点删除锁删除
- 抢锁线程主动轮询：有 watch 机制
- 羊群效应：删除事件唤醒大量线程抢锁？只 watch 比自己小的节点
- 单机不高可用：zookeeper高可用
- 主从同步数据不一致：zookeeper 最终一致性